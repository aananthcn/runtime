#! /usr/bin/python3

import sys
import json
import subprocess
import os

# G L O B A L   V A R I A B L E S
rbs_conf = rbs_cmd = ""
supported_commands = ["clean", "install"]
package_types = ["cmake", "makefile", "boost"]


# F U N C T I O N S
def get_package_type(pkgd):
    files = subprocess.run(["ls", pkgd], stdout=subprocess.PIPE).stdout.decode('utf-8').split("\n")
    if "Makefile" in files or "makefile" in files:
        return "makefile"
    elif "CMakeLists.txt" in files:
        return "cmake"
    elif "bootstrap.sh" in files and "boost-build.jam" in files:
        return "boost"
    else:
        print("RBS Error: Unknown package type found %s" % (pkgd))
        exit(-1)

def command_check(cmd):
    if cmd in supported_commands:
        return True
    else:
        return False

def out_folder_paths(domain, pwd):
    out_dir = pwd + "/out/" + domain
    bin_dir = out_dir + "/bin/"
    lib_dir = out_dir + "/lib/"
    return out_dir, bin_dir, lib_dir


def prepare_env_n_dir(conf, domain):
    # copy host environment and add the envs from json file
    env = os.environ.copy()
    for v in conf["toolchain"][domain]["env"]:
        env[v] = conf["toolchain"][domain]["env"][v]

    # create out folders and to env variable
    out_dir, bin_dir, lib_dir = out_folder_paths(domain, env["PWD"])
    subprocess.run(["mkdir", "-p", bin_dir, lib_dir])
    env["OUT_DIR"] = out_dir
    env["BIN_DIR"] = bin_dir
    env["LIB_DIR"] = lib_dir
    return env



def get_cmake_config_list(env, domain):
    out_dir = env["OUT_DIR"]
    inst_arg = "-DCMAKE_INSTALL_PREFIX:PATH="+out_dir
    if domain == "Linux":
        cfg_list = ["cmake", inst_arg, ".."]
    elif domain == "QNX":
        c_arg = "-DCMAKE_C_COMPILER="+rbs_conf["toolchain"][domain]["prefix"]+"gcc"
        cpp_arg = "-DCMAKE_CXX_COMPILER="+rbs_conf["toolchain"][domain]["prefix"]+"g++"
        find_arg = "-DCMAKE_FIND_ROOT_PATH="+out_dir
        cfg_list = ["cmake", inst_arg, c_arg, cpp_arg, find_arg, ".."]
        print(cfg_list)
    else:
        print("RBS Error: invalid domain - get_cmake_config_list()!")
        exit(-1)

    return cfg_list



def config_package(conf, env, pkg, pkgt):
    print("configure " + pkg)
    outstr = ""
    if pkgt == "makefile":
        return # do nothing
    if pkgt == "boost":
        pkgd = conf["packages"]["path"]+"/"+pkg
        outd = env["OUT_DIR"]
        #./bootstrap.sh --prefix=../../out/QNX/
        outstr = subprocess.run(["./bootstrap.sh", "--prefix="+outd], stdout=subprocess.PIPE, env=env, cwd=pkgd)
    elif pkgt == "cmake":
        pkgd = conf["packages"]["path"]+"/"+pkg
        domain = env["DOMAIN"]
        cfg_list = get_cmake_config_list(env, domain)
        build_dir = env["PWD"]+"/"+pkgd+"/build-"+domain

        subprocess.run(["mkdir", "-p", build_dir], stdout=subprocess.PIPE, env=env)
        outstr = subprocess.run(cfg_list, stdout=subprocess.PIPE, env=env, cwd=build_dir).stdout.decode('utf-8')
    else:
        print("RBS Error: invalid package to configure!")
        exit(-1)
    print(outstr)


def compile_package(conf, env, pkg, pkgt):
    print("compiling RBS package: %s" % (pkg))
    pkgd = conf["packages"]["path"]+"/"+pkg
    if pkgt == "makefile":
        outstr = subprocess.run(["make", "-C", pkgd], stdout=subprocess.PIPE, env=env).stdout.decode('utf-8')
    elif pkgt == "boost":
        if env["DOMAIN"] == "QNX":
            print("Note: file '/opt/qnx700/host/linux/x86_64/etc/qcc/gcc/5.4.0/default' should be configured to get right results!!")
        #./b2 -j8 install -d2+2 link=shared address-model=64 architecture=x86 threadapi=pthread binary-format=elf toolset=qcc
        # cxxflags="-Vgcc_ntox86_64_gpp -shared -std=gnu++0x -lang-c++ -fexceptions" linkflags="-Vgcc_ntox86_64_gpp -std=gnu++0x
        # -fexceptions" archiveflags="-Vgcc_ntox86_64_gpp" target-os=qnxnto --without-python --without-context --without-coroutine
        outstr = subprocess.run('./b2 -j8 install -d2+2 link=shared address-model=64 architecture=x86 threadapi=pthread '
        + 'abi=aapcs binary-format=elf toolset=qcc cxxflags="-Vgcc_ntox86_64_gpp -shared -std=gnu++0x -lang-c++ -fexceptions" '
        + 'linkflags="-Vgcc_ntox86_64_gpp -std=gnu++0x -fexceptions" archiveflags="-Vgcc_ntox86_64_gpp" target-os=qnxnto '
        + '--without-python --without-context --without-coroutine',
        shell=True, check=True, env=env, cwd=pkgd, stdout=subprocess.PIPE).stdout.decode('utf-8')
    elif pkgt == "cmake":
        build_dir = env["PWD"]+"/"+pkgd+"/build-"+env["DOMAIN"]
        outstr = subprocess.run(["make", "-C", build_dir], stdout=subprocess.PIPE, env=env).stdout.decode('utf-8')
    else:
        print("RBS Error: invalid package to compile!")
        exit(-1)
    print(outstr)


def run_package(conf, env, pkg, pkgt, cmd):
    print("Running RBS package: %s" % (pkg))
    pkgd = conf["packages"]["path"]+"/"+pkg
    if pkgt == "makefile":
        outstr = subprocess.run(["make", cmd, "-C", pkgd], stdout=subprocess.PIPE, env=env).stdout.decode('utf-8')
    print(outstr)


def install_package(conf, env, pkg, pkgt):
    print("Installing RBS package: %s" % (pkg))
    pkgd = conf["packages"]["path"]+"/"+pkg
    if pkgt == "makefile":
        outstr = subprocess.run(["make", "install", "-C", pkgd], stdout=subprocess.PIPE, env=env).stdout.decode('utf-8')
    elif pkgt == "boost":
        outstr = "Installation is part of compilation for boost type packages!"
    print(outstr)


def build_domain_packages(conf, domain, pkgs, cmd):
    print("\n\nRBS begins for %s..." % (domain))
    print("=" * (18+len(domain)))
    env = prepare_env_n_dir(conf, domain)

    # setup path & domain
    env["DOMAIN"] = domain
    if len(conf["toolchain"][domain]["path"]) > 0:
        env["PATH"] = conf["toolchain"][domain]["path"] + ":" + env["PATH"]

    # build packages for domain (QNX, Linux, ...)
    for pkg in pkgs:
        # identify package type
        pkgd = conf["packages"]["path"]+"/"+pkg
        pkgt = get_package_type(pkgd)
        print("Package type: " + pkgt)

        if len(cmd) > 0:
            run_package(conf, env, pkg, pkgt, cmd)
        else:
            config_package(conf, env, pkg, pkgt)
            compile_package(conf, env, pkg, pkgt)
            install_package(conf, env, pkg, pkgt)


def build_packages(conf, pkgs, cmd):
    for domain in conf["domains"]:
        if domain == "QNX":
            build_domain_packages(conf, domain, pkgs, cmd)
            continue

        if domain == "Linux":
            build_domain_packages(conf, domain, pkgs, cmd)
            continue

        # control shouldn't reach here
        print("RBS error: unsupported domain build configured: %s" % (domain))


if __name__ == '__main__':
    cmd_args = len(sys.argv)
    if cmd_args > 1:
        for i in range(1, cmd_args):
            if sys.argv[i] == "-c" and (i+1) <= cmd_args:
                rbs_cmd = sys.argv[i+1]
                i += 1
                cmdchk = command_check(rbs_cmd);
                if cmdchk == True:
                    continue
                else:
                    print("RBS Error: %s is not supported!" % (rbs_cmd))
                    exit(-1)
    else:
        print("usage:\n"+sys.argv[0]+" <rbs.json file>\n")
        exit(-1)

    # load RBS configuration from JSON file
    print("Loading %s..." % (sys.argv[1]))
    rbs_conf = json.load(open(sys.argv[1])) # Load the json file
    print("")
    print("Welcome to RBS - Runtime Build System!")
    print("%s is configured for the domain targets: %s" % (rbs_conf["title"], rbs_conf["domains"]))

    # identify the packages to be built
    print("\nPackages to be built:")
    packages = []
    for item in rbs_conf["packages"]["list"]:
        packages.append(item["pkg"])
    print(packages)

    # build packages for all domains...
    build_packages(rbs_conf, packages, rbs_cmd)